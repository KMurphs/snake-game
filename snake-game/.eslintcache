[{"C:\\PersonalProjects\\snake-game\\snake-game\\src\\index.tsx":"1","C:\\PersonalProjects\\snake-game\\snake-game\\src\\reportWebVitals.ts":"2","C:\\PersonalProjects\\snake-game\\snake-game\\src\\App.tsx":"3","C:\\PersonalProjects\\snake-game\\snake-game\\src\\store\\index.tsx":"4","C:\\PersonalProjects\\snake-game\\snake-game\\src\\login\\index.tsx":"5","C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\index.tsx":"6","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\generalHelpers.ts":"7","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\scrollHelpers.ts":"8","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\useCustomCss_vh.ts":"9","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-misc-controls\\modal.tsx":"10","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\useClickAnimation.ts":"11","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-form-controls\\input-with-moving-label.tsx":"12","C:\\PersonalProjects\\snake-game\\snake-game\\src\\login\\logo.tsx":"13","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-misc-controls\\hamburger-menu-control.tsx":"14","C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\keypad.tsx":"15","C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\board.tsx":"16","C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\utils.ts":"17","C:\\PersonalProjects\\snake-game\\snake-game\\src\\store\\type.ts":"18","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-utils\\local-storage.ts":"19"},{"size":627,"mtime":1610195425753,"results":"20","hashOfConfig":"21"},{"size":440,"mtime":1610195260116,"results":"22","hashOfConfig":"21"},{"size":8671,"mtime":1610554008041,"results":"23","hashOfConfig":"21"},{"size":5982,"mtime":1610554112396,"results":"24","hashOfConfig":"21"},{"size":4165,"mtime":1610554191439,"results":"25","hashOfConfig":"21"},{"size":6034,"mtime":1610555310202,"results":"26","hashOfConfig":"21"},{"size":701,"mtime":1610346593561,"results":"27","hashOfConfig":"21"},{"size":4972,"mtime":1610201624949,"results":"28","hashOfConfig":"21"},{"size":1253,"mtime":1610201624953,"results":"29","hashOfConfig":"21"},{"size":1223,"mtime":1610347122384,"results":"30","hashOfConfig":"21"},{"size":877,"mtime":1610434252502,"results":"31","hashOfConfig":"21"},{"size":2078,"mtime":1610353309694,"results":"32","hashOfConfig":"21"},{"size":6181,"mtime":1610555138094,"results":"33","hashOfConfig":"21"},{"size":544,"mtime":1610399822532,"results":"34","hashOfConfig":"21"},{"size":2412,"mtime":1610434531010,"results":"35","hashOfConfig":"21"},{"size":6467,"mtime":1610550829198,"results":"36","hashOfConfig":"21"},{"size":7886,"mtime":1610549001051,"results":"37","hashOfConfig":"21"},{"size":773,"mtime":1610550407502,"results":"38","hashOfConfig":"21"},{"size":599,"mtime":1610522523333,"results":"39","hashOfConfig":"21"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"16wjrny",{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"42"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"42"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"65"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70","usedDeprecatedRules":"42"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"42"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},"C:\\PersonalProjects\\snake-game\\snake-game\\src\\index.tsx",[],["84","85"],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\reportWebVitals.ts",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\App.tsx",["86","87","88"],"import React, { useEffect, useState } from 'react';\r\nimport './App.css';\r\nimport {\r\n  BrowserRouter as Router,\r\n  Switch,\r\n  Route,\r\n  Redirect\r\n} from \"react-router-dom\";\r\nimport Login from './login';\r\nimport Game from './game';\r\nimport { isOnProductionHost } from './custom-hooks/generalHelpers';\r\nimport { useResetToBaseURIOnLoad, useAppURI } from './custom-hooks/scrollHelpers';\r\nimport { useCustomCss_vh } from './custom-hooks/useCustomCss_vh';\r\nimport { Direction, TUser, SessionScore, ReduxUser } from './store/type';\r\nimport { fromLocalStorage, toLocalStorage } from './custom-utils/local-storage';\r\nimport { secsToString } from './game/utils';\r\n\r\n\r\n\r\ntype Props = {\r\n  isLoggedIn: boolean,\r\n  version: string,\r\n  onUserLogin: (user: TUser)=>void,\r\n  onChangePauseState: ()=>void,\r\n  onNextDirection: (dir: Direction | null)=>void,\r\n  onResetGame: ()=>void,\r\n  onLostGame: ()=>void,\r\n  onScorePoint: ()=>void,\r\n  onTimerTick: ()=>void,\r\n  onLogout: ()=>void,\r\n  onResultFeedback: ()=>void,\r\n  getNewUser: (name?: string)=>TUser,\r\n  user: ReduxUser,\r\n  nextSnakeDirection: Direction | null,\r\n  isPaused: boolean,\r\n  hasLost: boolean,\r\n  hasWon: boolean\r\n  level: number,\r\n  gameTimeScore: number,\r\n}\r\n\r\n/**\r\n * Returns the \"best\" inputs between \"session1\" and \"session2\"\r\n * @date 2021-01-13\r\n * @param {SessionScore} session1:SessionScore\r\n * @param {SessionScore} session2:SessionScore\r\n * @returns {SessionScore}\r\n */\r\nconst getBestSession = (session1: SessionScore, session2: SessionScore) => {\r\n  if(session1.level !== session2.level) { return session1.level > session2.level ? session1 : session2 } \r\n  if((session1.timeScore * session1.pointScore) < (session2.timeScore * session2.pointScore)) { return session2; } \r\n  return session1;\r\n}\r\n\r\n/**\r\n * Returns true if the input \"session1\" is \"greater\" that the input \"session2\"\r\n * @date 2021-01-13\r\n * @param {SessionScore} session1:SessionScore\r\n * @param {SessionScore} session2:SessionScore\r\n * @returns {boolean}\r\n */\r\nconst orderSessions = (session1: SessionScore, session2: SessionScore) => getBestSession(session1, session2) === session1;\r\n\r\n\r\n\r\nfunction App({\r\n  isLoggedIn, version, user, gameTimeScore, nextSnakeDirection, \r\n  isPaused, hasLost, hasWon, level,\r\n  onUserLogin, onLogout, onResetGame, onChangePauseState, onNextDirection, getNewUser, onResultFeedback, \r\n  onLostGame, onScorePoint, onTimerTick}: Props) {\r\n\r\n\r\n\r\n  /**\r\n   * Utility function that ensures that once the current direction from\r\n   * the user is read, the store must reset its copy to null.\r\n   * This allows the board to fallback on the current snake heading\r\n   * if the user does not react or provide a direction\r\n   * @date 2021-01-13\r\n   * @returns {Direction|null}\r\n   */\r\n  const grabNextDirection = ()=>{\r\n    nextSnakeDirection && onNextDirection(null);\r\n    return nextSnakeDirection;\r\n  }\r\n\r\n\r\n  /**\r\n   * Effect will run once and will display the current App version\r\n   */ \r\n  useEffect(()=>{\r\n    console.log(`Current App version: ${version}`);\r\n  },[])\r\n  \r\n\r\n\r\n\r\n  /**\r\n   * CSS Effect to help with full screen on mobiles\r\n   */ \r\n  useCustomCss_vh();\r\n  /**\r\n   * Effects that redirect the app to the default home page on refresh\r\n   */ \r\n  useResetToBaseURIOnLoad(\"snake-game\", ()=>!isOnProductionHost());\r\n  const uri = useAppURI(\"snake-game\");\r\n\r\n  \r\n  /**\r\n   * Local storage effect. Commit \"users\" state/cache object to storage.\r\n   * Set \"users\" to updated storage content\r\n   */\r\n  const [users, setUsers] = useState<TUser[]>([]);\r\n  useEffect(()=>{\r\n    (users.length > 0) && toLocalStorage(\"users\", users);\r\n    const storageUsers = fromLocalStorage(\"users\", []);\r\n    (users.length !== storageUsers.length) && setUsers(storageUsers);\r\n  }, [users])\r\n  \r\n\r\n\r\n  /**\r\n   * Users DB CRUD Ops\r\n   */\r\n  const createUser = (newUsername: string) => {\r\n    const newUser = getNewUser(newUsername);\r\n    setUsers(users => [...users, newUser]);\r\n    return newUser;\r\n  }\r\n  const updateUser = (username: string, session: SessionScore) => setUsers(users => users.map(u => {\r\n    (u.name === username) && (u.last = {...session});\r\n    (u.name === username) && (u.best = getBestSession(u.best, u.last));\r\n    return u;\r\n  }));\r\n  const deleteUser = (obsoleteUser: TUser) => setUsers(users => users.filter(u => u.name !== obsoleteUser.name));\r\n  const getUserByName = (username: string) => users.find(u => u.name.toLowerCase() === username.toLowerCase());\r\n  const getBestUser = () => users.sort((a,b) => orderSessions(a.best, b.best) ? 1 : -1)[0];\r\n\r\n\r\n\r\n  /**\r\n   * Effect that runs when game is terminated either because user won or lost. The user with its current score\r\n   * is pushed into the users application cache. The Local storage effect will be run subsequently, to commit \r\n   * to local storage\r\n   */\r\n  useEffect(()=>{\r\n    updateUser(user.name, user.current);\r\n  }, [hasLost, hasWon])\r\n\r\n\r\n  /**\r\n   * This component is rendered under \"Game\". Instead of loading the interface with Game with things that Game\r\n   * does not actually need, this component is fully built and is passed as Props to Game to be rendered.\r\n   */\r\n  const DetailsWithProps = () => <Details currentUser={getUserByName(user.name)} bestUser={getBestUser()} onLogout={onLogout}/>\r\n\r\n\r\n  return (\r\n    <Router basename={`${uri}`}>\r\n      <Switch>\r\n\r\n\r\n        {/* https://stackoverflow.com/questions/42123261/programmatically-navigate-using-react-router-v4 */}\r\n        {/* https://www.codegrepper.com/code-examples/javascript/Programmatically+navigate+using+react+router */}\r\n        <Route path={`/login`}>\r\n          {\r\n            isLoggedIn ? <Redirect to={`/play`} /> : <Login onLogin={onUserLogin} getUserByName={getUserByName} addUser={createUser}/>\r\n          }\r\n        </Route>\r\n\r\n          \r\n        <Route path={`/play`} render={({history})=>(\r\n          isLoggedIn ? <Game user={user} \r\n                             nextSnakeDirection={nextSnakeDirection}\r\n                             onResetGame={onResetGame}\r\n                             onChangePauseState={onChangePauseState}\r\n                             onNextDirection={onNextDirection}\r\n                             grabNextDirection={grabNextDirection}\r\n                             notifyGameFailure={onLostGame}\r\n                             notifyScorePoint={onScorePoint}\r\n                             onTimerTick={onTimerTick}\r\n                             onResultFeedback={onResultFeedback}\r\n                             isPaused={isPaused}\r\n                             hasLost={hasLost}\r\n                             DetailsFC={DetailsWithProps}\r\n                             hasWon={hasWon}\r\n                             level={level}\r\n                             gameTimeScore={gameTimeScore}\r\n                             /*backToWelcome={()=>history.push(`/welcome`)} *//> \r\n                     : <Redirect to={`/login`} />\r\n        )}/>\r\n\r\n\r\n\r\n\r\n        {/* Redirects */}\r\n        <Route path={`/`}>\r\n          <Redirect to={`/play`} />\r\n        </Route>\r\n        <Route path={`/*`}>\r\n          <Redirect to={`/login`} />\r\n        </Route>\r\n\r\n\r\n\r\n      </Switch>\r\n    </Router>  \r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ntype ResultProps = {\r\n  currentUser: TUser|undefined,\r\n  bestUser: TUser|undefined,\r\n  onLogout: ()=>void\r\n}\r\n\r\n/**\r\n * React Functional Component that appears in the side Panel on mobile\r\n */\r\nfunction Details({currentUser, bestUser, onLogout}: ResultProps){\r\n  return (\r\n    <div id=\"details\" className=\" p-4 pt-8 rounded-lg h-full flex flex-col justify-between items-stretch\">\r\n\r\n      <div>\r\n        <h1 className=\"text-xl pb-2\"><span>Current: </span><strong>{currentUser ? currentUser.name: \"None\"}</strong></h1>\r\n        {currentUser && (\r\n          <ul>\r\n            <li><span>Score: </span>{currentUser?.last.pointScore} points</li>\r\n            <li><span>Time: </span>{secsToString(currentUser?.last.timeScore)} sec</li>\r\n            <li><span>Level: </span>Level {currentUser?.last.level}</li>\r\n          </ul>\r\n        )}\r\n      </div>\r\n\r\n      <div>\r\n        <h1 className=\"text-xl pb-2\"><span>Best Overall: </span><strong>{bestUser ? bestUser.name: \"None\"}</strong></h1>\r\n        {bestUser && (\r\n          <ul>\r\n            <li><span>Score: </span>{bestUser?.best.pointScore} points</li>\r\n            <li><span>Time: </span>{secsToString(bestUser?.best.timeScore)} sec</li>\r\n            <li><span>Level: </span>Level {bestUser?.best.level}</li>\r\n          </ul>\r\n        )}\r\n      </div>\r\n\r\n      <div className=\"flex color-main justify-between flex-wrap \">\r\n        <button onClick={onLogout} className=\"btn mt-8 mx-2 w-full bg-red-600\">Logout</button>\r\n      </div>\r\n\r\n    </div>\r\n  )\r\n}","C:\\PersonalProjects\\snake-game\\snake-game\\src\\store\\index.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\login\\index.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\index.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\generalHelpers.ts",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\scrollHelpers.ts",["89","90"],"// https://javascriptio.com/view/4915713/react-navigation-that-will-smooth-scroll-to-section-of-the-page\r\n// https://codesandbox.io/s/falling-https-jwrj3?file=/src/App.tsx:636-686\r\n// https://stackoverflow.com/a/16171238/9034699\r\n\r\nimport { useEffect, useMemo } from \"react\";\r\n/**\r\n * When using multiple components on the same with different react router 'routes',\r\n * this hook will use (smooth) transition to get to bring the component with 'targetID' to\r\n * the top left of the page.\r\n * \r\n * \r\n * @param  {string} targetID\r\n * @param  {any} clickEvent?\r\n * @param  {string} targetURI?\r\n * @param  {boolean=false} smooth\r\n */\r\nexport const scrollIDIntoViewHelper = (targetID: string, clickEvent?: any, targetURI?: string, smooth: boolean = false)=>{\r\n  \r\n  // We are essentially hijacking the click event which does not really work with react router\r\n  clickEvent && clickEvent.preventDefault && clickEvent.preventDefault();\r\n\r\n  // Scroll element with provided id into view\r\n  const targetElmt = document.getElementById(targetID);\r\n  targetElmt && targetElmt.scrollIntoView(smooth ? { behavior: \"smooth\", block: \"start\" } : { block: \"start\" });\r\n\r\n  // Update the url\r\n  targetURI && window.history.pushState(targetID, targetID, `/${targetURI ? targetURI : targetID}`);\r\n}\r\n\r\n// useEffect(scrollURLIDIntoViewHelper) use with interval?\r\n/**\r\n * When using multiple components on the same with different react router 'routes',\r\n * this hook will use (smooth) transition to get to bring the component with 'targetID' to\r\n * the top left of the page.\r\n * This hook assumes that the route is actually the id of the component to scroll to\r\n * \r\n * @param  {boolean=false} smooth\r\n */\r\nexport const scrollURLIDIntoViewHelper = (smooth: boolean = false)=>{\r\n  \r\n  // This function assumes that the last uri corresponds to the id of the element\r\n  // that must be scrolled into view\r\n  const url = window.location.href.split(\"/\");\r\n  const target = url[url.length - 1];//.toLowerCase();\r\n  const element = document.getElementById(target);\r\n\r\n  // Adjust view to display component with id from uri\r\n  element && element.scrollIntoView(smooth ? { behavior: \"smooth\", block: \"start\" } : { block: \"start\" });\r\n}\r\n\r\n/**\r\n * This function will ensure that the application is redirected to \r\n * the \"uri\" input argument on load/page refresh.\r\n * \r\n * @param  {string=\"Home\"} uri\r\n */\r\nexport const useResetURIOnLoad = (uri: string = \"Home\") => {\r\n  const handleResetURI = () => window.history.pushState(uri, uri, `/${uri}`);\r\n  \r\n  useEffect(() => {\r\n    window.addEventListener(\"load\", handleResetURI);\r\n\r\n    return () => {\r\n      // Clean up the listener\r\n      window.removeEventListener(\"load\", handleResetURI);\r\n    };\r\n  });\r\n}\r\n\r\n\r\n/**\r\n * Attempts to extract the base URI of the application.\r\n * When used with react router, this is done before react router\r\n * start meddling with the urls.\r\n * \r\n * This function is probably not in its final form. But this will do while\r\n * I find something better instead.\r\n * \r\n * @param  {string=\"/\"} baseAppURI: Optional input if the logic to extract the uri fails.\r\n */\r\nexport const useAppURI = (baseAppURI: string = \"/\") =>{\r\n  const uri = useMemo(()=>{\r\n    const baseCurrURI = window.location.pathname.split(\"/\")[1]\r\n    const uri = (!baseCurrURI || (baseCurrURI === \"\")) ? `/${baseAppURI}` : `/${baseCurrURI}`; \r\n    return uri.replaceAll(\"//\", \"/\");\r\n  }, [1]);\r\n  return uri;\r\n}\r\n/**\r\n * When using react router with github pages and an application that lives at '<host>/baseUri/' , \r\n * refeshing the page causes github to send back a 404 Page.\r\n * This function will make sure to redirect the application the '<host>/baseUri/' after refreshing.\r\n * \r\n * onCondition is provided to avoid performing the redirection when 'condition()' evaluates to false.\r\n * This function is used until I find a better solution.\r\n * \r\n * @param  {string=\"Home\"} baseAppURI\r\n * @param  {()=>boolean} onCondition?\r\n */\r\nexport const useResetToBaseURIOnLoad = (baseAppURI?: string, onCondition?: ()=>boolean) => {\r\n  const uri = useAppURI(baseAppURI || \"/\");\r\n  \r\n  const handleResetURI = () => {\r\n    const condition = onCondition ? onCondition() : true;\r\n    condition && window.history.pushState(uri, uri, `${uri}`)\r\n  };\r\n  \r\n  useEffect(() => {\r\n    window.addEventListener(\"load\", handleResetURI);\r\n\r\n    return () => {\r\n      // Clean up the listener\r\n      window.removeEventListener(\"load\", handleResetURI);\r\n    };\r\n  });\r\n}\r\n// export const useSyncURIAndDisplay = ()=>{\r\n  \r\n//   // This function assumes that the last uri corresponds to the id of the element\r\n//   // that must be scrolled into view\r\n//   let url = window.location.href.split(\"/\");\r\n//   let target = url[url.length - 1].toLowerCase();\r\n//   let element = document.getElementById(target);\r\n\r\n//   // Adjust view to display component with id from uri\r\n//   element && element.scrollIntoView(smooth ? { behavior: \"smooth\", block: \"start\" } : { block: \"start\" });\r\n// }","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\useCustomCss_vh.ts",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-misc-controls\\modal.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-hooks\\useClickAnimation.ts",[],["91","92"],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-form-controls\\input-with-moving-label.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\login\\logo.tsx",["93","94","95"],"import { useCallback, useEffect, useLayoutEffect, useRef, useState } from \"react\"\r\nimport { useBoardDimension } from \"../game/utils\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Send back all number of the form: start + (delta * k)\r\n * Where k can be any non-zero positive integer as long as the resulting number stays less than end\r\n * \r\n * These number form an arithmetic progression.\r\n * \r\n * @date 2021-01-13\r\n * @param {number} delta:number - Distance between two consecutive produced numbers\r\n * @param {number} start:number - The initial point to which delta is added \r\n * @param {number} end:number - The maximum limit for the numbers produced\r\n * @returns {number[]} - List of numbers forming an arithmetic progression between start and end.\r\n */\r\nconst getProgressionUntil = (delta: number, start: number, end: number): number[] => \r\n  start < end \r\n  ? [start, ...getProgressionUntil(delta, start + delta, end)] \r\n  : []\r\n\r\n/**\r\n * Given the available length (\"items\" input), and the occupied length (\"length\" input), return how much\r\n * space must be added on the both side of the occupied space for it to be centered.\r\n * @date 2021-01-13\r\n * @param {number} items:number\r\n * @param {number} length:number\r\n * @returns {number} - how much length to put on each side of \"length\" for it to be centered in \"items\"\r\n */\r\nconst getMargin = (items: number, length: number) => \r\n  Math.max(Math.floor((items - length)/2), 0) \r\n\r\n\r\n\r\n/**\r\n * Contruct a snake logo on a grid (rows x cols). The snake logo must be drawn over \"xWidth\" cols and \"yHeight\" rows\r\n * @date 2021-01-13\r\n * @param {any} rows:number\r\n * @param {any} cols:number\r\n * @param {any} xWidth:number\r\n * @param {any} yHeight:number\r\n * @returns {any}\r\n */\r\nexport const getLogo = (rows: number, cols: number, xWidth: number, yHeight: number)=>{\r\n\r\n  const filter = (item: number, index: number) => index >= getMargin(cols, xWidth) && index < cols - getMargin(cols, xWidth)\r\n\r\n  // Find row of most top point\r\n  const topMargin = getMargin(rows, yHeight)\r\n\r\n  // Find entries on all 3 horizontal lines of the snake on grid\r\n  const row_top = Array(cols).fill(0).map((item, index) => cols * topMargin + index).filter(filter)\r\n  const row_center = Array(cols).fill(0).map((item, index) => cols * Math.floor(topMargin + yHeight * .5) + index).filter(filter)\r\n  const row_bottom = Array(cols).fill(0).map((item, index) => cols * (topMargin + yHeight) + index).filter(filter)\r\n\r\n  // Add the vertical bars for our snake logo\r\n  const col_left = getProgressionUntil(cols, row_top[0], row_center[0])\r\n  const col_right = getProgressionUntil(cols, row_center[row_center.length - 1], row_bottom[row_bottom.length - 1])\r\n\r\n  const first = row_bottom[0] - cols;\r\n  const last = row_top[row_top.length - 1] + cols;\r\n\r\n  // Remove duplicates, sort and return\r\n  const logo = new Set([first, ...row_bottom, ...col_right.reverse(), ...row_center.reverse(), ...col_left.reverse(), ...row_top, last]);\r\n  // const logo = new Set([...row_top, ...row_center, ...row_bottom, ...col_left, ...col_right]);\r\n  return Array.from(logo).reverse();\r\n  // return Array.from(logo).sort((a, b) => a - b);\r\n} \r\n\r\n\r\n\r\n/**\r\n * Various Incrementing functions\r\n */\r\nconst increment = (low: number, high: number, curr: number) => curr >= high ? low : curr + 1\r\nconst circularIncrement = (low: number, high: number, curr: number) => increment(low, high, curr) > high ? low : increment(low, high, curr);\r\nfunction* circularIterator(data: number[], start: number){\r\n  let index = ((start > data.length - 1) || (start < 0)) ? 0 : start;\r\n  let counter = 0;\r\n  while(++counter < data.length){\r\n    yield data[index];\r\n    index = increment(0, data.length - 1, index);\r\n  }\r\n  return counter;\r\n}\r\n/**\r\n * Given an index return a point on the straight line that passes by (x = 0, y = start) and (x = intervals, y = end).\r\n * \"index\" is actually a x coordinates between 0 and intervals, and the function returns the corresponding y coordinates.\r\n * @date 2021-01-13\r\n * @param {number} start:number\r\n * @param {number} end:number\r\n * @param {number} intervals:number\r\n * @param {number} index:number\r\n * @returns {number}\r\n */\r\nconst linearIncrement = (start: number, end: number, intervals: number, index: number) => start + index * (end - start) / intervals;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport default function LogoBoard(){\r\n\r\n  const [gridData, setGridData] = useState({cols: 1,rows: 1})\r\n  const gridSize = 20;\r\n  const xLength = 6;\r\n  const yLength = 10;\r\n  const {cols: grid_cols, rows: grid_rows} = gridData;\r\n  const grid = Array(grid_rows * grid_cols).fill(0).map((item, index) => ({row: Math.floor(index / grid_cols), col: index % grid_cols, index: index}))\r\n\r\n\r\n  const boardRef = useRef<HTMLDivElement>(null);\r\n  const getBoardDimension = useCallback((width, height) => setGridData({cols: Math.floor(width / gridSize), rows: Math.floor(height / gridSize)}), [])\r\n  useBoardDimension(boardRef.current, getBoardDimension)\r\n  \r\n\r\n  const logoBody = getLogo(grid_rows, grid_cols, xLength, yLength);\r\n\r\n\r\n\r\n\r\n  /**\r\n   * Main effect. It draws the snake logo in perpetual movement\r\n   */\r\n  useEffect(()=>{\r\n    let currPos = 0;\r\n    const snakeLength = logoBody.length //20\r\n    \r\n    const interval = setInterval(()=>{\r\n\r\n      currPos = increment(0, logoBody.length - 1, currPos);\r\n      let processed = 0;\r\n      let current = currPos - 1;\r\n      while(processed < logoBody.length - 1){\r\n        processed++;\r\n        current = increment(0, logoBody.length - 1, current);\r\n\r\n        const target = boardRef.current?.querySelector(`.grid-item.idx-${logoBody[current]}`);\r\n        if(!target) continue;\r\n        target.classList.remove(\"logo-snake\");\r\n        if(processed < snakeLength)target.classList.add(\"logo-snake\");\r\n        if(processed < snakeLength)(target as HTMLElement).style.opacity = `${linearIncrement(0, 1, snakeLength, processed)}`;\r\n      }\r\n      \r\n    }, 100) \r\n    return () => clearInterval(interval)\r\n  })\r\n\r\n\r\n\r\n\r\n  return (\r\n    <div className=\"logo-inner-container\" ref={boardRef}>\r\n    {\r\n      grid.map((item, index) => (<div key={index} className={`grid-item idx-${item.index} row-${item.row} col-${item.col}`}></div>))\r\n    }\r\n    </div>\r\n  )\r\n}","C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-misc-controls\\hamburger-menu-control.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\keypad.tsx",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\board.tsx",["96","97","98"],"import { useCallback, useEffect, useRef, useState } from \"react\"\r\nimport { Direction, ReduxUser } from \"../store/type\";\r\nimport { arePointsEqual, getInitialSnake, getNewCrumb, getNewSnake, hasDirectionChanged, markSnake, Point, Snake, useBoardDimension } from \"./utils\";\r\n\r\n\r\ntype Props = {\r\n  grabNextDirection: ()=> Direction | null,\r\n  notifyGameFailure: ()=> void,\r\n  onTimerTick: ()=> void,\r\n  notifyScorePoint: ()=> void,\r\n  isPaused: boolean,\r\n  hasLost: boolean,\r\n  hasWon: boolean,\r\n  user: ReduxUser\r\n}\r\n\r\nexport default function Board({grabNextDirection, isPaused, hasLost, hasWon, notifyGameFailure, notifyScorePoint, user, onTimerTick}: Props){\r\n\r\n  const [gridData, setGridData] = useState({cols: 1,rows: 1})\r\n  const gridSize = 20;\r\n  const {cols: grid_cols, rows: grid_rows} = gridData;\r\n  const grid = Array(grid_rows * grid_cols).fill(0).map((item, index) => ({row: Math.floor(index / grid_cols), col: index % grid_cols, index: index}))\r\n\r\n\r\n\r\n  // Get the dimensions of the board, the first time the layout is settled. Store these in gridData\r\n  const boardRef = useRef<HTMLDivElement>(null);\r\n  const getBoardDimension = useCallback((width, height) => setGridData({cols: Math.floor(width / gridSize), rows: Math.floor(height / gridSize)}), [])\r\n  useBoardDimension(boardRef.current, getBoardDimension)\r\n  \r\n\r\n\r\n\r\n  const snakeCSSClass = \"is-of-body\";\r\n  const crumbCSSClass = \"is-crumb\";\r\n  const gameControls = useRef<{snake: Snake, crumb: Point | null}>({\r\n    snake: getInitialSnake(grid_rows, grid_cols),\r\n    crumb: null\r\n  });\r\n  // This effect draws the initial snake on screen. Should only run once or twice\r\n  useEffect(()=>{\r\n    gameControls.current.snake = getInitialSnake(grid_rows, grid_cols);\r\n    markSnake(boardRef.current, gameControls.current.snake.body, snakeCSSClass, true);\r\n\r\n    // Cleanup current snake on screen\r\n    return () => markSnake(boardRef.current, gameControls.current.snake.body, snakeCSSClass, false);\r\n  }, [grid_rows, grid_cols, user.current.id])\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  const getManagementControls = ()=>({\r\n    getNextDirection: grabNextDirection,\r\n    getPausedState: () => isPaused,\r\n    getLostState: () => hasLost,\r\n    getWonState: () => hasWon,\r\n    notifyGameFailure: notifyGameFailure,\r\n    notifyCrumbAssimilation: notifyScorePoint,\r\n    getLevelSpeed: () => 500 - 50 * user.current.level,\r\n    onTimerTick: onTimerTick,\r\n  })\r\n  // Provide a way for the setInterval to reference the updated grabNextDirection and not \r\n  // the original value by closure\r\n  const managementControls = useRef(getManagementControls());\r\n  // Supporting effect, to update container for grabNextDirection so that the interval\r\n  // function always has the latest value\r\n  useEffect(()=>{\r\n    managementControls.current = getManagementControls()\r\n  }, [grabNextDirection, isPaused, notifyGameFailure, user.current.id])\r\n\r\n  // Tick effect, runs every so many millisecond. It is responsible for forcing\r\n  // the snake into movement. If the user hasnot provided a direction from (obtained from \"grabNextDirection\")\r\n  // the snake will move along its current heading\r\n  useEffect(()=>{\r\n    const interval = setInterval(()=>{\r\n      \r\n      // If state is paused or terminated, do nothing\r\n      if(managementControls.current.getPausedState()) return;\r\n      if(managementControls.current.getLostState()) return;\r\n      if(managementControls.current.getWonState()) return;\r\n\r\n      // Notify store to update user game time score\r\n      managementControls.current.onTimerTick();\r\n\r\n      // Make sure we have a crumb on the board\r\n      if(gameControls.current.crumb === null) {\r\n        const crumb = getNewCrumb(grid_rows, grid_cols, gameControls.current.snake.body);\r\n        gameControls.current.crumb = crumb;\r\n        const crumbNode = boardRef.current?.querySelector(`.grid-item.row-${crumb.y}.col-${crumb.x}`);\r\n        crumbNode?.classList.add(crumbCSSClass);\r\n      };\r\n      const crumb = gameControls.current.crumb;\r\n\r\n      // Get Snake direction\r\n      const nextDirection = managementControls.current.getNextDirection();\r\n      if(hasDirectionChanged(nextDirection || gameControls.current.snake.direction, gameControls.current.snake.direction)){\r\n        gameControls.current.snake.direction = nextDirection || gameControls.current.snake.direction;   \r\n      }\r\n  \r\n\r\n      // Build new body, and get tail\r\n      const [newSnake, tail] = getNewSnake(gameControls.current.snake.body, gameControls.current.snake.direction, crumb);\r\n      gameControls.current.snake.body = newSnake;\r\n      \r\n\r\n      // Draw snake head at new coordinates after movement\r\n      const headNode = boardRef.current?.querySelector(`.grid-item.row-${newSnake[0].y}.col-${newSnake[0].x}`);\r\n      const isInvalidHead = !headNode || headNode.classList.contains(snakeCSSClass) || (newSnake[0].x < 0) ||(newSnake[0].x >= grid_cols) || (newSnake[0].y < 0)|| (newSnake[0].y >= grid_rows);\r\n      // If new head is invalid, either because it sitting on top of another part of the body snake, \r\n      // or if it exists outside the borders of the board\r\n      isInvalidHead && managementControls.current.notifyGameFailure();\r\n      // Otherwise, we are good, draw it\r\n      !isInvalidHead && headNode?.classList.add(snakeCSSClass);\r\n\r\n\r\n\r\n      // // Handle the case where the snake assimilates the current crumb on screen\r\n      const assimilatedCrumb = arePointsEqual(newSnake[0], gameControls.current.crumb);\r\n      if(assimilatedCrumb){ \r\n        const crumb = gameControls.current.crumb;\r\n        gameControls.current.crumb = null;\r\n        const crumbNode = boardRef.current?.querySelector(`.grid-item.row-${crumb.y}.col-${crumb.x}`);\r\n        crumbNode?.classList.remove(crumbCSSClass);\r\n        managementControls.current.notifyCrumbAssimilation();\r\n        return;\r\n      }\r\n\r\n\r\n      // // Erase last snake element\r\n      if(tail.length === 0) return;\r\n      const tailNode = boardRef.current?.querySelector(`.grid-item.row-${tail[0].y}.col-${tail[0].x}`);\r\n      tailNode?.classList.remove(snakeCSSClass);\r\n\r\n    }, managementControls.current.getLevelSpeed());\r\n\r\n    return () => clearInterval(interval);\r\n  }, [grid_cols, grid_rows, user.current.id])\r\n\r\n\r\n\r\n\r\n\r\n\r\n  return (\r\n    <div className=\"logo-inner-container\" ref={boardRef}>\r\n    {\r\n      grid.map((item, index) => (\r\n        <div key={index} className={`grid-item idx-${item.index} row-${item.row} col-${item.col}`}></div>\r\n      ))\r\n    }\r\n    </div>\r\n  )\r\n}\r\n\r\n\r\n\r\n\r\n\r\n","C:\\PersonalProjects\\snake-game\\snake-game\\src\\game\\utils.ts",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\store\\type.ts",[],"C:\\PersonalProjects\\snake-game\\snake-game\\src\\custom-utils\\local-storage.ts",[],{"ruleId":"99","replacedBy":"100"},{"ruleId":"101","replacedBy":"102"},{"ruleId":"103","severity":1,"message":"104","line":93,"column":5,"nodeType":"105","endLine":93,"endColumn":7,"suggestions":"106"},{"ruleId":"107","severity":1,"message":"108","line":135,"column":9,"nodeType":"109","messageId":"110","endLine":135,"endColumn":19},{"ruleId":"103","severity":1,"message":"111","line":148,"column":6,"nodeType":"105","endLine":148,"endColumn":23,"suggestions":"112"},{"ruleId":"103","severity":1,"message":"113","line":86,"column":6,"nodeType":"105","endLine":86,"endColumn":9,"suggestions":"114"},{"ruleId":"103","severity":1,"message":"115","line":86,"column":7,"nodeType":"116","endLine":86,"endColumn":8},{"ruleId":"99","replacedBy":"117"},{"ruleId":"101","replacedBy":"118"},{"ruleId":"107","severity":1,"message":"119","line":1,"column":34,"nodeType":"109","messageId":"110","endLine":1,"endColumn":49},{"ruleId":"107","severity":1,"message":"120","line":80,"column":7,"nodeType":"109","messageId":"110","endLine":80,"endColumn":24},{"ruleId":"107","severity":1,"message":"121","line":81,"column":11,"nodeType":"109","messageId":"110","endLine":81,"endColumn":27},{"ruleId":"103","severity":1,"message":"122","line":46,"column":37,"nodeType":"109","endLine":46,"endColumn":44},{"ruleId":"103","severity":1,"message":"123","line":46,"column":59,"nodeType":"109","endLine":46,"endColumn":66},{"ruleId":"103","severity":1,"message":"124","line":72,"column":6,"nodeType":"105","endLine":72,"endColumn":71,"suggestions":"125"},"no-native-reassign",["126"],"no-negated-in-lhs",["127"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'version'. Either include it or remove the dependency array.","ArrayExpression",["128"],"@typescript-eslint/no-unused-vars","'deleteUser' is assigned a value but never used.","Identifier","unusedVar","React Hook useEffect has a missing dependency: 'user'. Either include it or remove the dependency array.",["129"],"React Hook useMemo has a missing dependency: 'baseAppURI'. Either include it or remove the dependency array.",["130"],"The 1 literal is not a valid dependency because it never changes. You can safely remove it.","Literal",["126"],["127"],"'useLayoutEffect' is defined but never used.","'circularIncrement' is assigned a value but never used.","'circularIterator' is defined but never used.","The ref value 'boardRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'boardRef.current' to a variable inside the effect, and use that variable in the cleanup function.","The ref value 'gameControls.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'gameControls.current' to a variable inside the effect, and use that variable in the cleanup function.","React Hook useEffect has a missing dependency: 'getManagementControls'. Either include it or remove the dependency array.",["131"],"no-global-assign","no-unsafe-negation",{"desc":"132","fix":"133"},{"desc":"134","fix":"135"},{"desc":"136","fix":"137"},{"desc":"138","fix":"139"},"Update the dependencies array to be: [version]",{"range":"140","text":"141"},"Update the dependencies array to be: [hasLost, hasWon, user]",{"range":"142","text":"143"},"Update the dependencies array to be: [baseAppURI]",{"range":"144","text":"145"},"Update the dependencies array to be: [getManagementControls, grabNextDirection, isPaused, notifyGameFailure, user.current.id]",{"range":"146","text":"147"},[3015,3017],"[version]",[4847,4864],"[hasLost, hasWon, user]",[3401,3404],"[baseAppURI]",[2796,2861],"[getManagementControls, grabNextDirection, isPaused, notifyGameFailure, user.current.id]"]